# 심플 소프트웨어 - 맥스 카넷

### Part 1. 프로그래머를 위한 원칙

- 좋은 소프트웨어 개발자가 되는 방법보다 훨씬 더 중요한 것이 있다. 바로 마음이다. 만약 내가 진정 ‘좋은' 프로그래머가 되고 싶다면 마음부터 먹어야 한다. 그 마음을 실제로 행동할 수 있는 각오가 반드시 필요하다. 만약 본인이 이제부터 책에서 나오는 방법을 충분히 실천할 각오가 되어있다면 이미 반은 성공이다.
    
    > *뛰어난 프로그래머가 되고자 하는 마음이 있어야만 뛰어난 프로그래머가 될 수 있다. 이런 마음이 없는 사람은 아무리 훈련을 받아도 뛰어난 프로그래머가 될 수 없다.*
    > 
- 일을 잘하는 프로그래머, 능력있는 프로그래머는 어떤 비밀을 갖추고 있을까?
    - 본인이 무슨 일을 하고 있는지 이해하고 의식하면서 행동하라. 뛰어난 프로그래머가 되는 일은 어려운 일이 아니다. 이해하고 의식하면서 행동하는 것이다. 사실 쉽지 않은 걸 알고 있지만 꾸준히 훈련을 통해 이뤄낼 수 있을 것 같다는 생각이 든다.
    - 단순히 글을 이해했다는 것은 능력과 전혀 상관이 없다. 가장 중요한 것은 ‘체화'라고 느껴진다. SOLID 원칙이 무엇인지, 높은 응집도와 낮은 결합도가 왜 중요한지 설명하는 자료는 수도 없이 많다. 하지만 **본인의 손 끝에서 그런 코드가 나오지 않는다면 전혀 의미가 없다.** 항상 나아지려고 노력하고 프로그래머에게 필요한 의미를 쫓자.
- 소프트웨어의 좋은 설계를 위해 지켜야할 원칙은 단순하다.
    
    > 1. *구현에 드는 수고보다 유지 보수에 드는 수고를 줄이는게 더 중요하다.*
    2*. 유지 보수에 드는 수고는 시스템의 복잡성에 비례한다.*
    > 

---

### Part 2. 소프트웨어 복잡성과 원인

- 우리는 코드가 복잡하다는 증거를 어디서 찾을 수 있을까?
    - 본문에서는 ‘그 코드를 수정할 생각을 하면 두렵다’ 라고 생각할 때라고 말한다. 개인적으로 이렇게 느낄 때는 테스트가 없고, 그 코드를 의존하는 컴포넌트가 너어무 많으며 심지어 테스트가 없을 때 나는 코드가 복잡하다고 느낀다. 개발 서적에서 왜 높은 결합도가 안좋은지, 왜 테스트가 필요한지 100번은 읽었겠지만 결국 느끼는게 최고다. 학생 때 부모님이 항상 공부하라고 말씀하셨을 때 열심히 거부하다가 이제 와서 이렇게 공부를 하고 있는 것을 보면. 끄덕.
- 우리는 프로그램에 닥치는 대로 아무 기능을 추가하는 것을 해선 안된다.
    - 수많은 요구사항이 쏟아져도 우린 ‘아니오'라고 말하며 기능 추가를 거절해야할 필요가 있다고 느껴진다. 기능의 추가는 또다른 관리 포인트의 증가며, 사실 해당 기능을 사용하는지 않는지는 개발자가 알아차리기 쉽지 않다. 그리고 사용하지 않는 기능들을 기획자분들이 직접 “이 기능은 사용하지 않으니 빼주세요" 라고 말하는 경우는 더욱 더 없다. 현재 어드민에 이런 방식으로 추가되고 남아있는 것들이 100개 단위다. 참 많은 것을 느낀다.
- 복잡성은 감옥이고 단순성은 자유다.
    - 나만 알아볼 수 있고, 나만 디버깅할 수 있으며, 내가 없으면 돌아가지 않는 코드를 작성하는 사람을 멀리 하자. 그는 심각한 병에 걸렸을 확률이 높다. 그렇지 않고서야 자신의 고용 보장성을 이런 식으로 무자비하게 보장하진 않았을테니까. 이렇게 말해놓고 내가 이런 사람일까봐 무섭다.

---

### Part 3. 단순성과 소프트웨어 설계

- 설계는 반드시 필요하며, 심지어 엄격한 설계가 필요하다.
    - 만약 엄격한 설계없이 소프트웨어가 몸집을 불려나가게 되면 결국은 개발자가 케어할 수 없는 능력까지 가버린다.
- 둘은 너무 많다. 중복을 제거하자.
    
    > *원칙적으로는 개발자가 코드 일부를 수정한 후에 코드의 다른 부분까지 그와 비슷하거나 똑같은 방식으로 작동하도록 수정할 필요가 없어야 한다.*
    > 
    - 중복이 유발하는 문제는 단순히 수정을 ‘N 번'해야된다는 사실로부터 시작해서 정말 수많은 문제를 유발한다. 주기적이고 습관적인 리팩토링이 어쩌면 중복을 제거할 수 있는 가장 근본적인 방법이 아닐까? 물론 통합하면 안되는 것은 통합하면 안된다.
    - 미래를 예측하지 말자. 어차피 미래는 틀려도 문제, 맞아도 문제다. 틀리면 구현한 소프트웨어를 밀고 다시 만들어야하니 문제다. 맞았다면 다음에도 맞출 수 있을거란 어리석은 자신감을 심어주기 때문에 문제다. 태풍은 반드시 온다. 미래를 예측해 절대 다치지 않겠다고 생각하지 말고 소프트웨어가 갖춰야할 견고한 설계를 통해 안아프게 맞는 것이 더 옳다.

---

### Part 4. 디버깅

- 단순히 문제를 해결하는 것이 디버깅이 아니다. 코드베이스가 갖고 있는 문제를 완전히 해결하는 것이다.
    - 눈에 띄는 증상이 아닌 근본적인 원인을 해결해야 한다. 만약 그런 과정이 너무 길고 힘들다면 잘게 쪼개서 해결하는 것이 바람직하다. 만약 “지금은 괜찮잖아? 꼭 지금 해야해?” 라고 질문이 생긴다면 이 문장을 떠올리자.
        
        > *명심하라. 소프트웨어에서 가장 신경 써야 할 부분은 미래다.*
        > 

---

### Part 5. 엔지니어링 팀에서 일하기

- 우선 문제를 인식하는 것이 문제다. 그리고 더 중요한 것은 신뢰를 얻는 일이다. 모두에게 완벽한 변화를 강요하지 말아라. 자신이 주장하는 타당성을 인정받는 것이 먼저다.
- 개발자에게 생산성이란 무엇일까?
    - 생산성은 결국 제품을 생산하는 일의 효율성을 말한다. 즉 개발자 생산성은 그 사람이 생산한 제품의 퀄리티와 동일한다.
- 코드 품질을 개선한다는 것은 개발자들이 평소에 구현하며 느꼈던 코드 개선점을 리스트업하는 것이 시작이다. 이 때 중요한 것은 문제가 무엇인지 명확하게 얘기하고 어떻게 해결할 수 있는지를 제시하는 것이다. 그리고 이를 한 곳으로 모아야 한다. 우선순위를 정하고 각자 할당해서 수행하면 된다.
- 리팩토링할 때는 기능에 주목하라.
    
    > *리팩토링을 위한 리팩토링을 한다면 리팩토링의 이름에 먹칠을 하는 것이나 다름없다.*
    > 
    - 정확히 나였다. 리팩토링이 목적인 리팩토링을 하고 있었다. 물론 요구사항과 아예 관련없는 코드는 아니었지만 제품과 시스템의 기능적 목표와 관련이 없는 리팩토링이 적지 않은 비율을 차지했다. 본문에서 이런 리팩토링은 아무도 관심을 보이지 않는 쓸모 없는 물건을 정리하는 행위처럼 아무것도 성취하지 못한다고 말한다.
    - 왠지 이 파트를 읽으면서 조금 찔렸다. 분명히 리팩토링을 수행하며 테스트도 작성하고 구조도 개선했지만 결국 고객에게 주는 가치는 전혀 없었다. 어쩌면 리팩토링이라는 행위에 취해서 그 자체가 목적인 바보같은 짓을 하고 있었던게 아닐까? 라는 생각이 들었다.
- 소프트웨어도 결국은 사람이 만드는 것이다.
    - 절대 함께 일하는 사람에게 무례하게 굴지 말자. 좋을게 하나도 없다. 틀린 부분을 맹렬히 비난하고 지적하는 것은 절대 절대 의미가 없다. 차라리 본인이 생각하는 좋은 소프트웨어를 만들기 위한 방법을 설명하고 이런 방법으로 작성해보면 어떻냐고 권해보는 것이 1억배는 효과적이다.
    - 또한 최근 코드 리뷰와 관련된 세션들을 살펴보면 공통적으로 언급되는 것 중 하나가 ‘코드와 개발자를 분리하는 것’이다. 코드에 대해서만 논하자. 스스로도 코드를 자신의 인격으로 치부하지 말자.

---

### Part 6. 소프트웨어 이해하기

- 코드를 작성하기 전에 공통적으로 언급된 방식은 ‘결정을 내리기 전에 관찰부터 하는 것'이다.
    - 반드시 문제를 해결해야한다는 생각을 버리고, 우선 문제가 뭔지부터 정확하게 정의하려고 노력하자. 또한 이런 문제들은 항상 사용자 관점으로 생각하자.
    - 최근 진행하고 있는 멘토링에서 멘토님이 한 얘기를 인용하자면 우린 결국 ‘스펙’을 개발한다. 소프트웨어 개발자는 사용자에게 제공해야하는 서비스를 소프트웨어를 통해 제공하는 것이다. 그렇다면 우리가 테스트해야 할 것은 서비스다. 수단에 홀려 이상한 곳으로 빠지지 말자. 본질을 잊지 말자.

---

### Part 7. 나아지기

- 소프트웨어를 바꾸는 시점은 간단하다. 너무 별로여서 도저히 못써먹을 때, 아무 조치도 하지 않는다면 그 때 떠난다.
    - 우리 서비스의 사용자들을 사로잡으려면 신규 기능도 필요하지만 점진적으로 불편함을 개선하는 점도 그에 못지 않게 중요하다는 의미다.
- 멍청한 아이디어는 반대하라. 반대할 수 없대도 반대하라. ‘아니오'라고 말하지 못한 책임은 모두가 지게 된다.
- 멍청해지기 싫다면 본인이 무엇때문에 멍청한지를 파악하는 것이 먼저다. 모르는 걸 모르는 것이 가장 멍청하다.
    - 만약 파악이 끝났다면 알아야할 내용들이 너무 많아서 절망감이 몰려올 것이다. 난 항상 그러고 있다. 최근엔 이런 느낌을 절망이 아닌 내가 탐구해야할 대륙이 훨씬 넓어졌다는 사실에 흥분감이 느껴진다.
    - 여기서 주의해야할 점은 머리가 아닌 손도 이해해야 한다는 점이다. 개인적으로 공부를 시작한 이래 가장 바보같은 학습법이 바로 *프런이었다. 기술이 나오게 된 이유와 어떤 점을 해결하는지를 강의에서 핵심만 뽑아 알려주며 당연히 ‘손’으로 실습한다. 하지만 강의가 끝나고 난 뒤 질문을 했을 때 제대로 답변할 수 없었다.
    - 얘기하고자 하는 핵심은 기술이 어떤 문제를 해결하는지, 어떻게 해결하는 지를 알았다면 다시 한번 스스로 고민해야한다는 것이다. 생각보다 이게 쉽지 않다. 본인이 머리를 쥐어짜며 알아낸 지식과 남에게 주입받은 지식의 깊이는 생각보다 많은 차이가 난다. **적어도 학습에선 의존성을 주입받지 말자. 본인이 해결하자.**

---

### 결론

- 좋은 개발자가 되고 싶다면 마음부터 먹어라. 좋은 개발자를 만들기 위한 이론은 충분하다. 하지만 그것이 입에서만 나온다면, 손 끝에선 악취만 풍긴다면 절대 좋은 개발자가 아니다.
- 코드에 주인의식을 가져야 한다. 책임감을 갖고 더러운 코드를 남기지 않겠다는 사명이 필요하다.
- 중복을 싫어하는 것으로는 부족하다. 끔찍하게 싫어하자. 남겨놓은 중복은 부메랑이 되어 돌아온다.
- 리팩토링을 위한 리팩토링을 하지 말자. 성과라고 불릴만한 의미있는 행동이 중심이 되어야 한다.
- 학습은 머리와 손, 둘을 모두 사용해 하는 것이다. 쉽게 번 돈은 쉽게 사라지듯, 쉽게 얻은 지식 역시 쉽게 사라진다. 머리를 고생시키자 제발.